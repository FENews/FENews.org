{"data":{"site":{"siteMetadata":{"title":"FENews"}},"markdownRemark":{"id":"46ec0aa9-e94f-5a1a-8fb1-05f4c4914b85","excerpt":"当你在组件里调用了   , 你觉得接下来会发生什么？ React 根据 state 改变后的   状态来更新 DOM 然后返回  。 看起来很简单，是吧。但是，到底是 React 去做了逻辑还是 React DOM ? 更新 DOM 结节听起来像是 React DOM…","html":"<p>当你在组件里调用了 <code class=\"language-text\">setState</code> , 你觉得接下来会发生什么？</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> clicked<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">handleClick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> clicked<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>clicked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Thanks<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n        Click me<span class=\"token operator\">!</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>Button <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>React 根据 state 改变后的 <code class=\"language-text\">{ clicked: true }</code> 状态来更新 DOM 然后返回 <code class=\"language-text\">&lt;h1&gt;Thanks&lt;/h1&gt;</code>。</p>\n<p>看起来很简单，是吧。但是，到底是 React 去做了逻辑还是 React DOM ?</p>\n<p>更新 DOM 结节听起来像是 React DOM 应该去做的。但是我们调用的是 <code class=\"language-text\">this.setState()</code>，并没有从 React DOM 中调用什么东西。还有就是 <code class=\"language-text\">React.Component</code> 基类是在 React 内部定义的。</p>\n<p>那么 <code class=\"language-text\">React.Component</code> 中的 <code class=\"language-text\">setState()</code> 到底是怎么更新 DOM 的？</p>\n<p>声明：就像其他博客上的大多数文章一样，你实际上并不需要了解其中的原理。这个文章其实是为那些喜欢了解背后原理的人而写的。完全选读！</p>\n<hr>\n<p>我可能觉得 <code class=\"language-text\">React.Component</code> 类中包含 DOM 更新的逻辑。</p>\n<p>如果是这样情况的话，那么为什么 <code class=\"language-text\">this.setState()</code> 也可以运行在其他的环境呢？比如说，从 <code class=\"language-text\">React.Component</code> 继承的组件运行在 React Native 环境中这种情况下。在这种情况下调用 <code class=\"language-text\">this.setState()</code> 跟我们上面的做的一样，但是 React Native 是运行在 Android 和 IOS 原生环境中的，而不是 DOM 环境。</p>\n<p>你可能对 React Test 或者 Shadllow Render 熟悉一些。这两种测试策略都允许你渲染组件，也可以在它们内部调用 <code class=\"language-text\">this.setState()</code> 。 但是它们都不工作在 DOM 环境中。</p>\n<p>如果你用过例如 <a href=\"https://github.com/facebook/react/tree/master/packages/react-art\">React ART</a> 这样的渲染器（renderer），你可能也知道可以在一个页面里用多个渲染器（renderer）。（比如说，ART 组件可以运行在 React DOM 树中）基于这种情况，那么也就意味着全局的标识或变量这种方案是不可能的。</p>\n<p>因此 <strong>React Component 是一种委托。委托特定的平台去处理 state 的状态更新</strong>。在我们了解它是怎么做的之前，首先让我们来深入探讨下 React 是如果做分包的，和为什么它要这么做。</p>\n<hr>\n<p>有一种常见的误解认为 React 渲染引擎包含在 <code class=\"language-text\">react</code> 这个包中。其实不是这样的。</p>\n<p>实际上，自从 <a href=\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\">React 0.14</a>分包后，<code class=\"language-text\">react</code> 包有意地只暴露了定义组件的API。 React渲染引擎的大部分实现都在 <code class=\"language-text\">renderer</code> 中。</p>\n<p><code class=\"language-text\">react-dom</code>、<code class=\"language-text\">react-dom/server</code>、 <code class=\"language-text\">react-native</code>、<code class=\"language-text\">react-test-renderer</code>、<code class=\"language-text\">react-art</code> 这是一些 <code class=\"language-text\">renderer</code> 的例子（<a href=\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\">你可以编写你的 <code class=\"language-text\">renderer</code></a>）</p>\n<p>这就是为什么 <code class=\"language-text\">react</code> 包那么重要而不用关心你的目标平台是什么。它的所有导出，例如 <code class=\"language-text\">React.Component</code>、<code class=\"language-text\">React.createElement</code>、<code class=\"language-text\">React.Children</code>还有<a href=\"https://reactjs.org/docs/hooks-intro.html\">Hooks</a>，都是独立于目标平台的。不管你是运行在 React DOM、React DOM Server、或者 React Native 中，你的组件都将以相同的方式导入，使用。</p>\n<p>相比之下，渲染器（renderer）包公开了特定于平台的 API，比如说 <code class=\"language-text\">ReactDOM.render()</code> 它允许一个 React 的结构挂载到一个 DOM 节点中。每个渲染器（renderer）都提供了类似上面的 API。理想情况下，大部分的组件不需要从渲染器（renderer）中导入任何东西。这使得它们更加轻量。</p>\n<p><strong>大部分人都认为 React 渲染引擎的实现在每个特定的渲染器（renderer）中</strong>。\n每个渲染器（renderer）中都包含有相同的代码 — 我们把它叫做协调器（reconciler）。在构建阶段我们为了更好的性能，将协调器（reconciler）和渲染器（renderer）代码打包到一个高度优化的 bundle 包里。（复制代码通常情况下对包的大小的控制不太友好，但是大多数 React 的开发者同时只需要用一种渲染器（renderer），比如说 <code class=\"language-text\">react-dom</code>。）</p>\n<p>这里要说明的是，<code class=\"language-text\">react</code> 包只是提供给了我们用 React 功能的方法，其实不知道任何关于它们怎么实现的细节。渲染器（renderer）包（<code class=\"language-text\">react-dom</code>，<code class=\"language-text\">react-native</code>，等等）提供了实现 React 功能的具体实现还有一些特定平台的逻辑。其中的一些代码是共享的（协调器（reconciler）），那些都是特有平台的具体实现。</p>\n<hr>\n<p>那么我们现在知道为什么 react react-dom 包需要都更新到最新的版本了。我们举个栗子，当 React16.3 添加了 Context API， React 包提供了 <code class=\"language-text\">React.createContext()</code> 这个方法。</p>\n<p>但是 <code class=\"language-text\">React.createContext()</code> 事实上就没有实现 Context API 这个新功能。那么 React DOM 和 React DOM Server 的实现就会不一样，比如说 <code class=\"language-text\">CreateContext()</code> 返回一些普通的对象。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// A bit simplified</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createContext</span><span class=\"token punctuation\">(</span>defaultValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> context <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    _currentValue<span class=\"token punctuation\">:</span> defaultValue<span class=\"token punctuation\">,</span>\n    Provider<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    Consumer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Provider <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.provider'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token punctuation\">:</span> context\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  context<span class=\"token punctuation\">.</span>Consumer <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token punctuation\">:</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'react.context'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    _context<span class=\"token punctuation\">:</span> context<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> context<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当你在代码中使用 <code class=\"language-text\">&lt;MyContext.Provider&gt;</code> 或者 <code class=\"language-text\">&lt;MyContext.Consumer&gt;</code> 的时候，这个时候取决于我们的渲染器（renderer） 怎么去渲染它们。 React DOM 是一种监听方法，React DOM Server 可能是另一种不同的做法。</p>\n<p><strong>那么如果你把 <code class=\"language-text\">react</code> 更新到16.3+但是没有相应的更新 <code class=\"language-text\">react-dom</code>，那么你就会用了一个没有实现 <code class=\"language-text\">Provider</code> 和 <code class=\"language-text\">Consumer</code> 类型的 渲染器（renderer）</strong> 这就是老版本的 <code class=\"language-text\">react-dom</code> 会报 <em>fail saying these types are invalid</em> 这个错误的原因。</p>\n<p>在 React Native 中也会有上面同样的警告。但是不同于 React DOM，React 的发布版本不会立刻就对应到一个 React Native 的版本。React Native 有独立的发布计划表。更新的渲染器（renderer）代码将会在几周后单独同步更新到 React Native 的项目中。这就是为什么一些新功能在 React Native 和 React DOM 可用的时间点不同的原因。</p>\n<hr>\n<p>好的，我们已经知道了 <code class=\"language-text\">react</code> 包中没有包含我们感兴趣的内容，因为这些实现都在像 <code class=\"language-text\">react-dom</code>，<code class=\"language-text\">react-native</code> 这样的渲染器（renderer）中。但是这依然没有回答我们上面的问题。<code class=\"language-text\">React.Component</code> 中的 <code class=\"language-text\">setState()</code> 到底是怎么跟响应的渲染器（renderer）通信的？</p>\n<p><strong>答案就是每个渲染器（renderer）都在创建的类里面设置了一个特殊字段</strong>。这个字段就是 <code class=\"language-text\">updater</code>。它不是你要来设置的 — 它是 React DOM，React DOM Server 或者 React Native 在创建对象的实例后设置的。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Inside React DOM</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMUpdater<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Inside React DOM Server</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactDOMServerUpdater<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Inside React Native</span>\n<span class=\"token keyword\">const</span> inst <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">YourComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>props <span class=\"token operator\">=</span> props<span class=\"token punctuation\">;</span>\ninst<span class=\"token punctuation\">.</span>updater <span class=\"token operator\">=</span> ReactNativeUpdater<span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以查看 <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\"><code class=\"language-text\">React Component</code> 中 <code class=\"language-text\">setState</code> 的实现</a> 它们做的就是代理到渲染器（renderer）中，让它去处理。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// A bit simplified</span>\n<span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>partialState<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Use the `updater` field to talk back to the renderer!</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updater<span class=\"token punctuation\">.</span><span class=\"token function\">enqueueSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> partialState<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React DOM Server <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\">可能会忽略 State 的更新，然后警告你</a>\n而 React DOM 和 React Native 会让协调器（reconciler）<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\">处理</a>。</p>\n<p>那么这就是为什么 <code class=\"language-text\">this.setState()</code> 可以更新 DOM 即使它定义在 React 包中。它去读取 React DOM 设置的 <code class=\"language-text\">this.update</code> 字段，让 React DOM 安排并处理更新。</p>\n<hr>\n<p>现在我们知道在在类中 <code class=\"language-text\">setState()</code> 是怎么处理的，那么问题来了，Hooks 是怎么处理的呢？</p>\n<p>当开发者第一次看到 <a href=\"https://reactjs.org/docs/hooks-intro.html\">Hook API提案</a>，他们总是在想： <code class=\"language-text\">useState</code> 是怎么知道该干什么的？我们假设它比基于 <code class=\"language-text\">React.Component</code> 的 <code class=\"language-text\">setState()</code> 更加神奇。</p>\n<p>但是正如我们今天所看到的，基于类的 <code class=\"language-text\">setState()</code> 实现是一种错觉。除了将调用转发给当前渲染器（renderer）之外，它不会执行任何操作。<code class=\"language-text\">useState</code> Hook <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56\">做了同样的事情</a>。</p>\n<p><strong>Hooks 使用 “dispatcher” 对象，而不是 <code class=\"language-text\">updater</code> 字段</strong>。当你调用 <code class=\"language-text\">React.useState()</code>，<code class=\"language-text\">React.useEffect()</code>，或者其他内置 Hooks 的时候，它们通通转发给当前的 dispatcher。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// In React (simplified a bit)</span>\n<span class=\"token keyword\">const</span> React <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Real property is hidden a bit deeper, see if you can find it!</span>\n  __currentDispatcher<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>一些特殊的渲染器（renderer）是在渲染你的组件前设置 dispatcher 的。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// In React DOM</span>\n<span class=\"token keyword\">const</span> prevDispatcher <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span>__currentDispatcher<span class=\"token punctuation\">;</span>\nReact<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> ReactDOMDispatcher<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  result <span class=\"token operator\">=</span> <span class=\"token function\">YourComponent</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Restore it back</span>\n  React<span class=\"token punctuation\">.</span>__currentDispatcher <span class=\"token operator\">=</span> prevDispatcher<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>比如说，React DOM Server 的实现在<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\">这里</a>，React DOM 和 React Native 的共同实现协调器（reconciler）在<a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\">这里</a>。</p>\n<p>这就是为什么像 <code class=\"language-text\">react-dom</code> 这样的渲染器（renderer）需要访问你调用 Hooks 的时候的 react 包。否则，你的组件将不能访问到 dispatcher ！当你在同一组件树中有多个 <a href=\"https://github.com/facebook/react/issues/13991\">React副本</a> 时，这可能不 work。这总是导致了一些模糊的错误，因此 Hooks 会强迫你解决包重复问题。</p>\n<p>你可以在技术上覆盖 dispatcher 已获取高级工具功能，但是我们不鼓励这么做（其实 <code class=\"language-text\">__currentDispatcher</code> 属性不是真实的属性名称， 你可以在 React 项目中找到真实的名字）。举个栗子，React DevTools 将使用 <a href=\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\">特殊的提案 - built dispatcher</a> 通过捕获 JavaScript 堆栈树来观察 Hooks。</p>\n<p>这也意味着 Hooks 本身并不依赖于 React。如果将来有更多的库，想要重用相同的原始 Hooks, 理论上 dispatcher 可以单独封装到一个包里并导出一个。在实际开发中，我们要避免过早的抽象直到我们真正需要抽象的时候。</p>\n<p><code class=\"language-text\">updater</code> 字段 和 <code class=\"language-text\">__currentDispatcher</code> 对象都是通用编程原则的形式叫做 <em>依赖注入</em>。在这两种情况下，渲染器（renderer）将诸如 setState 之类的功能的实现“注入”到通用的 React包 中，以使组件更具声明性。</p>\n<p>当你用 React 的时候根本不用去想它是怎么工作的。我们希望 React 用户花更多时间考虑他们的应用程序代码，而不是考虑依赖注入这样的抽象概念。但是如果你想知道 <code class=\"language-text\">this.setState()</code> 或者 <code class=\"language-text\">useState()</code> 这些东西的工作原理，我希望这篇文章能到帮到你。</p>\n<p>原文地址：<em><a href=\"https://overreacted.io/how-does-setstate-know-what-to-do/\">https://overreacted.io/how-does-setstate-know-what-to-do/</a></em></p>","frontmatter":{"title":"setState如何知道该做什么？","date":"2019年02月26日","description":"setState如何知道该做什么？","translators":null,"tags":["React","React setState","翻译"]}}},"pageContext":{"slug":"/2019-02-26---how-does-setstate-know-what-to-do/","previous":{"fields":{"slug":"/2019-02-22--chrome-js-loading-priorities/"},"frontmatter":{"title":"Chrome 中 JavaScript 加载优先级"}},"next":{"fields":{"slug":"/2019-02-24--faster-async-functions-and-promises/"},"frontmatter":{"title":"异步（async）函数和 promise 性能优化"}}}}